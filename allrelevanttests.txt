using System;
using System.IO;
using System.Security.Cryptography;
using Parquet.Meta;
using Parquet.Meta.Proto;

namespace Parquet.Test.Encryption;

internal static class TestCryptoUtils {
    public static ThriftCompactProtocolReader R(byte[] buf)
        => new ThriftCompactProtocolReader(new MemoryStream(buf));

    public static ThriftCompactProtocolReader R(Stream s)
        => new ThriftCompactProtocolReader(s);

    public static byte[] Le16(short v) => BitConverter.GetBytes(v);

    public static byte[] FrameGcm(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
        int len = nonce12.Length + ciphertext.Length + tag16.Length;
        using var ms = new MemoryStream();
        ms.Write(BitConverter.GetBytes(len), 0, 4);
        ms.Write(nonce12, 0, nonce12.Length);
        ms.Write(ciphertext, 0, ciphertext.Length);
        ms.Write(tag16, 0, tag16.Length);
        return ms.ToArray();
    }

    public static byte[] FrameCtr(byte[] nonce12, byte[] ciphertext) {
        int len = nonce12.Length + ciphertext.Length;
        using var ms = new MemoryStream();
        ms.Write(BitConverter.GetBytes(len), 0, 4);
        ms.Write(nonce12, 0, nonce12.Length);
        ms.Write(ciphertext, 0, ciphertext.Length);
        return ms.ToArray();
    }

    public static AesGcm NewAesGcm(byte[] key) {
#if NET8_0_OR_GREATER
        return new AesGcm(key, 16);
#else
        return new AesGcm(key);
#endif
    }

    public static byte[] BuildAad(byte[] prefix, byte[] fileUnique, ParquetModules module, short? rg = null, short? col = null, short? page = null) {
        using var ms = new MemoryStream();
        ms.Write(prefix, 0, prefix.Length);
        ms.Write(fileUnique, 0, fileUnique.Length);
        ms.WriteByte((byte)module);
        if(rg.HasValue)
            ms.Write(Le16(rg.Value), 0, 2);
        if(col.HasValue)
            ms.Write(Le16(col.Value), 0, 2);
        if(page.HasValue)
            ms.Write(Le16(page.Value), 0, 2);
        return ms.ToArray();
    }

    public static byte[] XorCtr(ICryptoTransform ecbEncryptor, byte[] iv16, byte[] input) {
        byte[] counter = (byte[])iv16.Clone();
        byte[] output = new byte[input.Length];
        int i = 0;
        while(i < input.Length) {
            byte[] ks = new byte[16];
            ecbEncryptor.TransformBlock(counter, 0, 16, ks, 0);

            int n = Math.Min(16, input.Length - i);
            for(int j = 0; j < n; j++)
                output[i + j] = (byte)(input[i + j] ^ ks[j]);

            for(int p = 15; p >= 12; p--)  // big-endian increment
                if(++counter[p] != 0)
                    break;

            i += n;
        }
        return output;
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {

    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class AadOrdinalTests {
        private static readonly byte[] Key = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();
        private static readonly byte[] Prefix = Encoding.ASCII.GetBytes("ord-reset");
        private static readonly byte[] Unique = new byte[] { 1, 3, 3, 7 };
        private static byte[] EncryptHeader(short rg, short col, short pageOrd, string txt) {
            byte[] plain = Encoding.ASCII.GetBytes(txt);
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] tag = new byte[16];
            byte[] ct = new byte[plain.Length];

            byte[] aad = Prefix
                .Concat(Unique)
                .Concat(new byte[] { (byte)ParquetModules.Data_PageHeader })
                .Concat(BitConverter.GetBytes(rg))
                .Concat(BitConverter.GetBytes(col))
                .Concat(BitConverter.GetBytes(pageOrd))
                .ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            gcm.Encrypt(nonce, plain, ct, tag, aad);
            return TestCryptoUtils.FrameGcm(nonce, ct, tag);
        }

        [Fact]
        public void Ordinal_Resets_Per_Column_And_RowGroup() {
            var dec = new AES_GCM_V1_Encryption { FooterEncryptionKey = Key, AadPrefix = Prefix, AadFileUnique = Unique };

            // RG0 COL0 page0
            byte[] rg0c0p0 = EncryptHeader(0, 0, 0, "rg0c0p0");
            Assert.Equal(Encoding.ASCII.GetBytes("rg0c0p0"),
                dec.DecryptDataPageHeader(R(rg0c0p0), 0, 0, 0));

            // RG0 COL0 page1
            byte[] rg0c0p1 = EncryptHeader(0, 0, 1, "rg0c0p1");
            Assert.Equal(Encoding.ASCII.GetBytes("rg0c0p1"),
                dec.DecryptDataPageHeader(R(rg0c0p1), 0, 0, 1));

            // RG0 COL1 page0 (ordinal resets to 0 for a new column)
            byte[] rg0c1p0 = EncryptHeader(0, 1, 0, "rg0c1p0");
            Assert.Equal(Encoding.ASCII.GetBytes("rg0c1p0"),
                dec.DecryptDataPageHeader(R(rg0c1p0), 0, 1, 0));

            // RG1 COL0 page0 (ordinal resets to 0 for a new row group)
            byte[] rg1c0p0 = EncryptHeader(1, 0, 0, "rg1c0p0");
            Assert.Equal(Encoding.ASCII.GetBytes("rg1c0p0"),
                dec.DecryptDataPageHeader(R(rg1c0p0), 1, 0, 0));

            // Negative checks: wrong ordinals/rg/col must fail
            Assert.ThrowsAny<CryptographicException>(() =>
                dec.DecryptDataPageHeader(R(rg0c0p0), 0, 0, 1));
            Assert.ThrowsAny<CryptographicException>(() =>
                dec.DecryptDataPageHeader(R(rg0c1p0), 0, 0, 0));
            Assert.ThrowsAny<CryptographicException>(() =>
                dec.DecryptDataPageHeader(R(rg1c0p0), 0, 0, 0));
        }

        private static byte[] Frame(byte[] n, byte[] c, byte[] t) {
            int len = n.Length + c.Length + t.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(n, 0, n.Length);
            ms.Write(c, 0, c.Length);
            ms.Write(t, 0, t.Length);
            return ms.ToArray();
        }
        private static ThriftCompactProtocolReader R(byte[] buf) => new ThriftCompactProtocolReader(new MemoryStream(buf));

        [Fact]
        public void ColumnOrdinal_Is_Enforced() {
            byte[] plain = Encoding.ASCII.GetBytes("hdr");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] tag = new byte[16];
            byte[] ct = new byte[plain.Length];

            // Encrypt for column 0
            byte[] aad = Prefix
                .Concat(Unique)
                .Concat(new byte[] { (byte)ParquetModules.Data_PageHeader })
                .Concat(BitConverter.GetBytes((short)0)) // rg
                .Concat(BitConverter.GetBytes((short)0)) // col 0
                .Concat(BitConverter.GetBytes((short)0)) // page 0
                .ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            gcm.Encrypt(nonce, plain, ct, tag, aad);
            byte[] framed = Frame(nonce, ct, tag);

            var dec = new AES_GCM_V1_Encryption { FooterEncryptionKey = Key, AadPrefix = Prefix, AadFileUnique = Unique };

            // Correct column works
            Assert.Equal(plain, dec.DecryptDataPageHeader(R(framed), 0, 0, 0));

            // Wrong column fails
            Assert.ThrowsAny<CryptographicException>(() =>
                dec.DecryptDataPageHeader(R(framed), 0, 1, 0));
        }
    }
}

using System;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class AadPrefixBehaviorTests {
        private static readonly byte[] Key = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] FileUnique = new byte[] { 1, 2, 3, 4 };
        private const short RG = 0, COL = 0;

        [Fact]
        public void Uses_Stored_AadPrefix_When_SupplyAadPrefix_False() {
            byte[] storedPrefix = Encoding.ASCII.GetBytes("stored-prefix");
            byte[] plaintext = Encoding.ASCII.GetBytes("col-metadata");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // AAD = storedPrefix || (fileUnique || module || RG || COL)
            byte[] aadSuffix = new byte[] { }
                .Concat(FileUnique)
                .Concat(new byte[] { (byte)ParquetModules.ColumnMetaData })
                .Concat(BitConverter.GetBytes(RG))
                .Concat(BitConverter.GetBytes(COL))
                .ToArray();
            byte[] aad = storedPrefix.Concat(aadSuffix).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            byte[] ct = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ct, tag, aad);

            var enc = new AES_GCM_V1_Encryption {
                FooterEncryptionKey = Key,
                AadPrefix = storedPrefix,        // stored value, not supplied
                AadFileUnique = FileUnique
            };

            byte[] framed = TestCryptoUtils.FrameGcm(nonce, ct, tag);
            byte[] outBytes = enc.DecryptColumnMetaData(TestCryptoUtils.R(framed), RG, COL);
            Assert.Equal(plaintext, outBytes);
        }

        [Fact]
        public void Missing_Supplied_AadPrefix_Fails_Cleanly() {
            // Build bytes with a *required* supplied prefix "runtime-prefix"
            byte[] suppliedPrefix = Encoding.ASCII.GetBytes("runtime-prefix");
            byte[] plaintext = Encoding.ASCII.GetBytes("offset-index");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            byte[] aadSuffix = new byte[] { }
                .Concat(FileUnique)
                .Concat(new byte[] { (byte)ParquetModules.OffsetIndex })
                .Concat(BitConverter.GetBytes(RG))
                .Concat(BitConverter.GetBytes(COL))
                .ToArray();
            byte[] aad = suppliedPrefix.Concat(aadSuffix).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            byte[] ct = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ct, tag, aad);

            // Simulate caller forgetting to provide the supplied prefix (AadPrefix = null/empty)
            var enc = new AES_GCM_V1_Encryption {
                FooterEncryptionKey = Key,
                AadPrefix = Array.Empty<byte>(),
                AadFileUnique = FileUnique
            };

            byte[] framed = TestCryptoUtils.FrameGcm(nonce, ct, tag);

            // Wrong AAD -> Auth tag mismatch (platform may throw AuthenticationTagMismatchException or CryptographicException)
            Assert.ThrowsAny<CryptographicException>(() => {
                enc.DecryptOffsetIndex(TestCryptoUtils.R(framed), RG, COL);
            });
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class AadPrefixPrecedenceTests : TestBase {

        private static ParquetSchema MakeSchema()
            => new ParquetSchema(new DataField<string>("s"));

        private static DataColumn MakeColumn(ParquetSchema schema, params string[] values) {
            var sField = (DataField)schema.Fields[0];
            return new DataColumn(sField, values);
        }

        private static string B64Key(int bytes = 16)
            => Convert.ToBase64String(Enumerable.Range(1, bytes).Select(i => (byte)i).ToArray());

        [Theory]
        [InlineData(false)] // AES-GCM-V1
        [InlineData(true)]  // AES-GCM-CTR-V1
        public async Task StoredPrefix_Ignores_Wrong_Supplied_At_Read(bool useCtr) {
            // Write: store the prefix in the file (SupplyAadPrefix=false)
            string key = B64Key(16);
            string storedPrefix = "stored-prefix-precedence";
            var writeOpts = new ParquetOptions {
                FooterEncryptionKey = key,
                AADPrefix = storedPrefix,
                SupplyAadPrefix = false,  // store in file
                UseCtrVariant = useCtr
            };

            ParquetSchema schema = MakeSchema();
            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: writeOpts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(MakeColumn(schema, "a", "b", "c"));
            }

            // Read: deliberately pass a WRONG prefix; it must be ignored because file stores its own.
            ms.Position = 0;
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                FooterEncryptionKey = key,
                AADPrefix = "WRONG-WRONG-WRONG", // should not matter
            });

            Assert.True(reader.IsEncryptedFile);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var df = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(df);

            Assert.Equal(new[] { "a", "b", "c" }, col.Data);
        }

        [Theory]
        [InlineData(false)]
        [InlineData(true)]
        public async Task StoredPrefix_Also_Works_When_Supplied_Is_Null(bool useCtr) {
            // Control: showing that a null supplied prefix also works (already covered in other tests,
            // but included here for completeness with the same writer settings).
            string key = B64Key(32);
            var writeOpts = new ParquetOptions {
                FooterEncryptionKey = key,
                AADPrefix = "stored-AAD-here",
                SupplyAadPrefix = false,
                UseCtrVariant = useCtr
            };

            ParquetSchema schema = MakeSchema();
            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: writeOpts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(MakeColumn(schema, "x", "y", "z"));
            }

            ms.Position = 0;
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                FooterEncryptionKey = key,
                AADPrefix = null
            });

            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var df = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(df);
            Assert.Equal(new[] { "x", "y", "z" }, col.Data);
        }
    }
}

using System;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class AadSuffixModuleTests {
        [Theory]
        [InlineData(ParquetModules.ColumnIndex)]
        [InlineData(ParquetModules.OffsetIndex)]
        [InlineData(ParquetModules.BloomFilter_Header)]
        [InlineData(ParquetModules.BloomFilter_Bitset)]
        [InlineData(ParquetModules.ColumnMetaData)]
        public void NonPage_Modules_Decrypt_With_Correct_AAD(ParquetModules module) {
            byte[] key = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();
            byte[] prefix = Encoding.ASCII.GetBytes("aad_prefix_idx");
            byte[] unique = new byte[] { 0xDE, 0xAD, 0xBE, 0xEF };
            const short RG = 2, COL = 4;

            byte[] plaintext = Encoding.ASCII.GetBytes($"ok-{module}");
            byte[] aad = TestCryptoUtils.BuildAad(prefix, unique, module, RG, COL);
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] ct = new byte[plaintext.Length];
            byte[] tag = new byte[16];

            using AesGcm gcm = TestCryptoUtils.NewAesGcm(key);
            gcm.Encrypt(nonce, plaintext, ct, tag, aad);

            var enc = new AES_GCM_V1_Encryption { FooterEncryptionKey = key, AadPrefix = prefix, AadFileUnique = unique };
            byte[] framed = TestCryptoUtils.FrameGcm(nonce, ct, tag);

            byte[] result = module switch {
                ParquetModules.ColumnIndex => enc.DecryptColumnIndex(TestCryptoUtils.R(framed), RG, COL),
                ParquetModules.OffsetIndex => enc.DecryptOffsetIndex(TestCryptoUtils.R(framed), RG, COL),
                ParquetModules.BloomFilter_Header => enc.BloomFilterHeader(TestCryptoUtils.R(framed), RG, COL),
                ParquetModules.BloomFilter_Bitset => enc.BloomFilterBitset(TestCryptoUtils.R(framed), RG, COL),
                ParquetModules.ColumnMetaData => enc.DecryptColumnMetaData(TestCryptoUtils.R(framed), RG, COL),
                _ => throw new NotSupportedException()
            };

            Assert.Equal(plaintext, result);
        }

    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class AesCtrBehaviorTests {
        private static readonly byte[] Key256 = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] AadPrefix = Encoding.ASCII.GetBytes("spec_ctr_split");
        private static readonly byte[] AadFileUnique = new byte[] { 0x10, 0x20, 0x30, 0x40 };
        private const short RG = 5, COL = 9, PAGE = 1;

        private static byte[] AadSuffix(byte module, short? rg, short? col, short? page) {
            using var ms = new MemoryStream();
            ms.Write(AadFileUnique, 0, AadFileUnique.Length);
            ms.WriteByte(module);
            if(rg.HasValue)
                ms.Write(BitConverter.GetBytes(rg.Value), 0, 2);
            if(col.HasValue)
                ms.Write(BitConverter.GetBytes(col.Value), 0, 2);
            if(page.HasValue)
                ms.Write(BitConverter.GetBytes(page.Value), 0, 2);
            return ms.ToArray();
        }

        [Fact]
        public void DataPage_Uses_CTR_Framing_And_Decrypts() {
            byte[] plaintext = Encoding.ASCII.GetBytes("ctr-page-bytes");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // Build 16-byte IV = nonce || 0x00000001
            byte[] iv = new byte[16];
            Buffer.BlockCopy(nonce, 0, iv, 0, 12);
            iv[12] = 0;
            iv[13] = 0;
            iv[14] = 0;
            iv[15] = 1;

            // Encrypt via CTR keystream (ECB)
            byte[] ciphertext;
            using(var aes = Aes.Create()) {
                aes.Mode = CipherMode.ECB;
                aes.Padding = PaddingMode.None;
                aes.Key = Key256;
                using ICryptoTransform enc = aes.CreateEncryptor();
                ciphertext = XorWithCtr(enc, iv, plaintext);
            }

            byte[] framed = TestCryptoUtils.FrameCtr(nonce, ciphertext);
            var encCtr = new AES_GCM_CTR_V1_Encryption {
                FooterEncryptionKey = Key256,
                AadPrefix = AadPrefix,
                AadFileUnique = AadFileUnique
            };

            byte[] outBytes = encCtr.DecryptDataPage(TestCryptoUtils.R(framed), RG, COL, PAGE);
            Assert.Equal(plaintext, outBytes);
        }

        [Fact]
        public void DataPageHeader_Stays_GCM_And_Decrypts() {
            byte[] plaintext = Encoding.ASCII.GetBytes("gcm-header");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            byte[] aad = AadPrefix.Concat(AadSuffix((byte)ParquetModules.Data_PageHeader, RG, COL, PAGE)).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key256, 16);
#else
            using var gcm = new AesGcm(Key256);
#endif
            byte[] ct = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ct, tag, aad);

            byte[] framed = TestCryptoUtils.FrameGcm(nonce, ct, tag);

            var encCtr = new AES_GCM_CTR_V1_Encryption {
                FooterEncryptionKey = Key256,
                AadPrefix = AadPrefix,
                AadFileUnique = AadFileUnique
            };

            byte[] outBytes = encCtr.DecryptDataPageHeader(TestCryptoUtils.R(framed), RG, COL, PAGE);
            Assert.Equal(plaintext, outBytes);
        }

        [Fact]
        public void DataPageHeader_With_CTR_Framing_Is_Rejected() {
            // GCM is required for headers; feeding CTR-framed bytes should fail the GCM framing checks
            byte[] bogusHdr = Encoding.ASCII.GetBytes("hdr");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // Make CTR ciphertext
            byte[] iv = new byte[16];
            Buffer.BlockCopy(nonce, 0, iv, 0, 12);
            iv[12] = 0;
            iv[13] = 0;
            iv[14] = 0;
            iv[15] = 1;
            byte[] ciphertext;
            using(var aes = Aes.Create()) {
                aes.Mode = CipherMode.ECB;
                aes.Padding = PaddingMode.None;
                aes.Key = Key256;
                using ICryptoTransform enc = aes.CreateEncryptor();
                ciphertext = XorWithCtr(enc, iv, bogusHdr);
            }

            byte[] framed = TestCryptoUtils.FrameCtr(nonce, ciphertext);
            var encCtr = new AES_GCM_CTR_V1_Encryption {
                FooterEncryptionKey = Key256,
                AadPrefix = AadPrefix,
                AadFileUnique = AadFileUnique
            };

            Assert.Throws<InvalidDataException>(() => {
                encCtr.DecryptDataPageHeader(TestCryptoUtils.R(framed), RG, COL, PAGE);
            });
        }

        private static byte[] XorWithCtr(ICryptoTransform ecbEncryptor, byte[] iv16, byte[] input) {
            byte[] counter = (byte[])iv16.Clone();
            byte[] output = new byte[input.Length];
            int i = 0;
            while(i < input.Length) {
                byte[] ks = new byte[16];
                ecbEncryptor.TransformBlock(counter, 0, 16, ks, 0);

                int n = Math.Min(16, input.Length - i);
                for(int j = 0; j < n; j++)
                    output[i + j] = (byte)(input[i + j] ^ ks[j]);

                // increment last 4 bytes (big-endian)
                for(int p = 15; p >= 12; p--)
                    if(++counter[p] != 0)
                        break;
                i += n;
            }
            return output;
        }

        // Utility: fresh decryptor with CTR variant
        private static AES_GCM_CTR_V1_Encryption Ctr() => new AES_GCM_CTR_V1_Encryption {
            FooterEncryptionKey = Key256,
            AadPrefix = Encoding.ASCII.GetBytes("ctr-multi"),
            AadFileUnique = new byte[] { 0xCA, 0xFE, 0xBA, 0xBE }
        };


        [Theory]
        [InlineData(1)]             // tiny
        [InlineData(15)]            // just under block
        [InlineData(16)]            // exact block
        [InlineData(17)]            // crosses block
        [InlineData((4 * 1024) + 7)]  // not multiple of 16, multiple blocks
        [InlineData(256 * 1024)]    // 256 KiB many blocks
        public void DataPage_CTR_RoundTrips_VariousSizes(int size) {
            AES_GCM_CTR_V1_Encryption encCtr = Ctr();
            byte[] plain = new byte[size];
            for(int i = 0; i < plain.Length; i++)
                plain[i] = (byte)(i & 0xFF);

            // Use writer API to ensure nonce/IV framing is correct
            byte[] framed = encCtr.EncryptDataPage(plain, rowGroupOrdinal: 0, columnOrdinal: 0, pageOrdinal: 0);

            var r = new ThriftCompactProtocolReader(new MemoryStream(framed));
            byte[] outBytes = encCtr.DecryptDataPage(r, 0, 0, 0);

            Assert.Equal(plain, outBytes);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(3)]
        [InlineData(31)]
        [InlineData(32)]
        public void DictionaryPage_CTR_RoundTrips_VariousSizes(int size) {
            AES_GCM_CTR_V1_Encryption encCtr = Ctr();
            byte[] plain = new byte[size];
            for(int i = 0; i < plain.Length; i++)
                plain[i] = (byte)((i * 7) & 0xFF);

            byte[] framed = encCtr.EncryptDictionaryPage(plain, rowGroupOrdinal: 1, columnOrdinal: 2);

            var r = new ThriftCompactProtocolReader(new MemoryStream(framed));
            byte[] outBytes = encCtr.DecryptDictionaryPage(r, 1, 2);

            Assert.Equal(plain, outBytes);
        }

        [Fact]
        public void DataPage_CTR_ZeroLength_Is_Valid() {
            AES_GCM_CTR_V1_Encryption encCtr = Ctr();
            byte[] framed = encCtr.EncryptDataPage(Array.Empty<byte>(), rowGroupOrdinal: 2, columnOrdinal: 3, pageOrdinal: 4);

            var r = new ThriftCompactProtocolReader(new MemoryStream(framed));
            byte[] outBytes = encCtr.DecryptDataPage(r, 2, 3, 4);

            Assert.Empty(outBytes);
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class ColumnEncryptionE2ETests : TestBase {
        private static ParquetSchema MakeSchema()
            => new ParquetSchema(new DataField<string>("s"));

        [Fact]
        public async Task A_PageEncryption_GcmV1_RoundTrip() {
            ParquetSchema schema = MakeSchema();
            var opts = new ParquetOptions {
                FooterEncryptionKey = Convert.ToBase64String(Enumerable.Range(1, 16).Select(i => (byte)i).ToArray()),
                AADPrefix = "suite-a",
                SupplyAadPrefix = false,     // store prefix in file
                UseCtrVariant = false        // GCM profile
            };

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                var sField = (DataField)schema.Fields[0];
                await rg.WriteColumnAsync(new DataColumn(sField, new[] { "x", "y", "z" }));
            }

            ms.Position = 0;
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                FooterEncryptionKey = opts.FooterEncryptionKey
            });

            Assert.True(reader.IsEncryptedFile);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var rf = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(rf);
            Assert.Equal(new[] { "x", "y", "z" }, col.Data);
        }

        [Fact]
        public async Task B_PageEncryption_CtrVariant_RoundTrip() {
            ParquetSchema schema = MakeSchema();
            var opts = new ParquetOptions {
                FooterSigningKey = "sixteen-byte-key",  // 16 bytes UTF-8
                AADPrefix = "suite-b",
                SupplyAadPrefix = false,
                UseCtrVariant = true                 // CTR bodies, GCM headers
            };

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                var sField = (DataField)schema.Fields[0];
                await rg.WriteColumnAsync(new DataColumn(sField, Enumerable.Range(0, 100).Select(i => i.ToString()).ToArray()));
            }

            ms.Position = 0;
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                FooterSigningKey = opts.FooterSigningKey
            });

            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var rf = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(rf);
            Assert.Equal(100, col.Data.Length);
            Assert.Equal("0", (string)col.Data.GetValue(0)!);
            Assert.Equal("99", (string)col.Data.GetValue(99)!);
        }

        [Fact]
        public async Task C_PageEncryption_MissingPrefix_Fails_When_SupplyAadPrefix_True() {
            ParquetSchema schema = MakeSchema();
            var opts = new ParquetOptions {
                FooterEncryptionKey = Convert.ToBase64String(Enumerable.Range(1, 32).Select(i => (byte)i).ToArray()),
                AADPrefix = "require-supply",
                SupplyAadPrefix = true,          // do not store prefix in file
                UseCtrVariant = false
            };

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                var sField = (DataField)schema.Fields[0];
                await rg.WriteColumnAsync(new DataColumn(sField, new[] { "a", "b" }));
            }

            ms.Position = 0;
            await Assert.ThrowsAsync<InvalidDataException>(async () => {
                using ParquetReader _ = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                    FooterEncryptionKey = opts.FooterEncryptionKey,
                    AADPrefix = null     // not supplied -> should fail
                });
            });
        }
    }
}

using System;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class DictionaryPage_Tests {
        private static readonly byte[] Key16 = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();
        private static readonly byte[] Key32 = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] Prefix = Encoding.ASCII.GetBytes("dict");
        private static readonly byte[] Unique = new byte[] { 0x11, 0x22, 0x33, 0x44 };
        private const short RG = 1, COL = 2;

        [Theory]
        [InlineData(false)] // AES_GCM_V1
        [InlineData(true)]  // AES_GCM_CTR_V1
        public void DictionaryPageHeader_GCM_NoPageOrdinal(bool ctrVariant) {
            byte[] key = ctrVariant ? Key32 : Key16;
            byte[] plaintext = Encoding.ASCII.GetBytes("dict-hdr");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // AAD = prefix || unique || module(Dictionary_PageHeader) || rg || col
            byte[] aad = Prefix
              .Concat(Unique)
              .Concat(new byte[] { (byte)ParquetModules.Dictionary_PageHeader })
              .Concat(BitConverter.GetBytes(RG))
              .Concat(BitConverter.GetBytes(COL))
              .ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(key, 16);
#else
      using var gcm = new AesGcm(key);
#endif
            byte[] ct = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ct, tag, aad);

            byte[] framed = TestCryptoUtils.FrameGcm(nonce, ct, tag);

            EncryptionBase dec = ctrVariant
              ? new AES_GCM_CTR_V1_Encryption { FooterEncryptionKey = key, AadPrefix = Prefix, AadFileUnique = Unique }
              : new AES_GCM_V1_Encryption { FooterEncryptionKey = key, AadPrefix = Prefix, AadFileUnique = Unique };

            byte[] outBytes = dec.DecryptDictionaryPageHeader(TestCryptoUtils.R(framed), RG, COL);
            Assert.Equal(plaintext, outBytes);

            // Negative: pretending there is a page ordinal in AAD must fail
            byte[] aadWrong = aad.Concat(BitConverter.GetBytes((short)0)).ToArray();
            byte[] tag2 = new byte[16];
            byte[] ct2 = new byte[plaintext.Length];
            byte[] nonce2 = RandomNumberGenerator.GetBytes(12);
            gcm.Encrypt(nonce2, plaintext, ct2, tag2, aadWrong);
            byte[] framedWrong = TestCryptoUtils.FrameGcm(nonce2, ct2, tag2);
            Assert.ThrowsAny<CryptographicException>(() =>
              dec.DecryptDictionaryPageHeader(TestCryptoUtils.R(framedWrong), RG, COL));
        }

        [Fact]
        public void DictionaryPage_Body_AES_GCM_V1_uses_GCM_NoPageOrdinal() {
            var gcmAlg = new AES_GCM_V1_Encryption { FooterEncryptionKey = Key16, AadPrefix = Prefix, AadFileUnique = Unique };
            byte[] plaintext = Enumerable.Range(0, 123).Select(i => (byte)i).ToArray();
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // AAD for Dictionary Page body (GCM): prefix || unique || module(Dictionary_Page) || rg || col   (NO page)
            byte[] aad = Prefix
              .Concat(Unique)
              .Concat(new byte[] { (byte)ParquetModules.Dictionary_Page })
              .Concat(BitConverter.GetBytes(RG))
              .Concat(BitConverter.GetBytes(COL))
              .ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key16, 16);
#else
      using var gcm = new AesGcm(Key16);
#endif
            byte[] ct = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ct, tag, aad);

            byte[] framed = TestCryptoUtils.FrameGcm(nonce, ct, tag);
            byte[] outBytes = gcmAlg.DecryptDictionaryPage(TestCryptoUtils.R(framed), RG, COL);
            Assert.Equal(plaintext, outBytes);
        }

        [Fact]
        public void DictionaryPage_Body_AES_GCM_CTR_V1_uses_CTR_NoAAD() {
            var ctrAlg = new AES_GCM_CTR_V1_Encryption { FooterEncryptionKey = Key32, AadPrefix = Prefix, AadFileUnique = Unique };
            byte[] plaintext = Encoding.ASCII.GetBytes("dict-page-ctr");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // Build 16B IV = nonce || 0x00000001
            byte[] iv = new byte[16];
            Buffer.BlockCopy(nonce, 0, iv, 0, 12);
            iv[12] = 0;
            iv[13] = 0;
            iv[14] = 0;
            iv[15] = 1;

            byte[] ciphertext;
            using(var aes = Aes.Create()) {
                aes.Mode = CipherMode.ECB;
                aes.Padding = PaddingMode.None;
                aes.Key = Key32;
                using ICryptoTransform enc = aes.CreateEncryptor();
                ciphertext = XorCtr(enc, iv, plaintext);
            }

            byte[] framed = TestCryptoUtils.FrameCtr(nonce, ciphertext);
            byte[] outBytes = ctrAlg.DecryptDictionaryPage(TestCryptoUtils.R(framed), RG, COL);
            Assert.Equal(plaintext, outBytes);
        }

        private static byte[] XorCtr(ICryptoTransform ecbEncryptor, byte[] iv16, byte[] input) {
            byte[] counter = (byte[])iv16.Clone();
            byte[] output = new byte[input.Length];
            int i = 0;
            while(i < input.Length) {
                byte[] ks = new byte[16];
                ecbEncryptor.TransformBlock(counter, 0, 16, ks, 0);
                int n = Math.Min(16, input.Length - i);
                for(int j = 0; j < n; j++)
                    output[i + j] = (byte)(input[i + j] ^ ks[j]);
                for(int p = 15; p >= 12; p--)
                    if(++counter[p] != 0)
                        break; // big-endian increment
                i += n;
            }
            return output;
        }

        [Fact]
        public void DictionaryPage_Encrypted_As_Dictionary_Fails_When_Decoded_As_DataPage() {
            // Encrypt a tiny dict page body with GCM (AES_GCM_V1) and try to decrypt with DecryptDataPage (module=Data_Page)
            var enc = new AES_GCM_V1_Encryption { FooterEncryptionKey = Key16, AadPrefix = Prefix, AadFileUnique = Unique };
            byte[] pt = Encoding.ASCII.GetBytes("mod-swap");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] aad = Prefix
              .Concat(Unique)
              .Concat(new byte[] { (byte)ParquetModules.Dictionary_Page })
              .Concat(BitConverter.GetBytes(RG))
              .Concat(BitConverter.GetBytes(COL))
              .ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key16, 16);
#else
  using var gcm = new AesGcm(Key16);
#endif
            byte[] ct = new byte[pt.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, pt, ct, tag, aad);
            byte[] framed = TestCryptoUtils.FrameGcm(nonce, ct, tag);

            Assert.ThrowsAny<CryptographicException>(() => {
                enc.DecryptDataPage(TestCryptoUtils.R(framed), RG, COL, pageOrdinal: 0); // wrong module id -> AAD mismatch
            });
        }
    }
}

using System;
using System.IO;
using System.Threading.Tasks;
using Xunit;
using Parquet.Data;
using Parquet.Schema;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Parquet.Encryption;
namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class EncryptionHeaderTests {
        [Fact]
        public async Task Gcm_HeaderSizesAndOffsets_Match_OnDisk_Frames() {
            // --- Arrange: write a tiny encrypted file (GCM, AAD prefix stored) ---
            string outDir = Path.Combine(Environment.CurrentDirectory, "interop-artifacts");
            Directory.CreateDirectory(outDir);
            string path = Path.Combine(outDir, "gcm_sizes_offsets.parquet");

            var schema = new ParquetSchema(
                new DataField<int>("id"),
                new DataField<string>("name")
            );

            var opts = new ParquetOptions {
                FooterEncryptionKey = "footerKey-16byte",
                AADPrefix = "mr-suite",
                SupplyAadPrefix = false,      // store prefix in file
                UseCtrVariant = false
            };

            using(FileStream fs = System.IO.File.Create(path))
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, fs, formatOptions: opts)) {
                writer.CompressionMethod = CompressionMethod.None; // keep simple
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(new DataColumn((DataField)schema.Fields[0], new[] { 1, 2, 3, 4 }));
                await rg.WriteColumnAsync(new DataColumn((DataField)schema.Fields[1], new[] { "alice", "bob", "carol", "dave" }));
            }

            // --- Act: open with reader so we have metadata + decrypter ---
            using ParquetReader reader = await ParquetReader.CreateAsync(path, new ParquetOptions {
                FooterEncryptionKey = "footerKey-16byte",
                AADPrefix = "mr-suite"
            });

            FileMetaData meta = reader.Metadata!;

            RowGroup rg0 = meta.RowGroups[0];
            ColumnChunk cc0 = rg0.Columns[0];                // first column: "id"
            short rgOrd = rg0.Ordinal!.Value;
            short colOrd = (short)rg0.Columns.IndexOf(cc0);
            EncryptionBase decr = meta.Decrypter!;

            // Start position should be exactly the column chunk's DataPageOffset
            long expectedFirstHeaderOffset = cc0.MetaData!.DataPageOffset;

            long encTotal = 0;      // on-disk total (encHeader + encBody for all pages)
            long plainTotal = 0;    // plaintext total (header bytes + uncompressed body sizes)
            int valuesSeen = 0;
            short pageOrd = 0;

            using FileStream raw = System.IO.File.OpenRead(path);
            raw.Seek(expectedFirstHeaderOffset, SeekOrigin.Begin);
            Assert.Equal(expectedFirstHeaderOffset, raw.Position);

            while(valuesSeen < cc0.MetaData.NumValues) {
                long posBeforeHeader = raw.Position;

                // Decrypt header (this consumes the encrypted header bytes from the stream)
                byte[] decHeader = decr.DecryptDataPageHeader(
                    new ThriftCompactProtocolReader(raw), rgOrd, colOrd, pageOrd);

                long posAfterHeader = raw.Position;
                int encHeaderLen = checked((int)(posAfterHeader - posBeforeHeader)); // bytes we just consumed on disk

                // Parse plaintext PageHeader to get sizes
                PageHeader ph;
                using(var ms = new MemoryStream(decHeader, writable: false))
                    ph = PageHeader.Read(new ThriftCompactProtocolReader(ms));

                Assert.Equal(PageType.DATA_PAGE, ph.Type);

                // The encrypted BODY follows immediately; parquet-mr will read exactly ph.CompressedPageSize bytes
                int encBodyLen = ph.CompressedPageSize;

                // Sanity: the very first header offset should equal DataPageOffset
                if(pageOrd == 0)
                    Assert.Equal(expectedFirstHeaderOffset, posBeforeHeader);

                // Skip over the encrypted body to the next page header (or end of chunk)
                raw.Seek(encBodyLen, SeekOrigin.Current);

                // Accumulate counts
                encTotal += encHeaderLen + encBodyLen;
                plainTotal += decHeader.Length + ph.UncompressedPageSize;
                valuesSeen += ph.DataPageHeader!.NumValues;
                pageOrd++;
            }

            // --- Assert: metadata totals match what was physically written ---
            Assert.Equal(encTotal, cc0.MetaData.TotalCompressedSize);
            Assert.Equal(plainTotal, cc0.MetaData.TotalUncompressedSize);
        }
    }
}

using System;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class EncryptionPrimitives_WriteTests {
        private static readonly byte[] Key16 = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();
        private static readonly byte[] Key32 = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] Prefix = Encoding.ASCII.GetBytes("writer-aad");
        private static readonly byte[] Unique = new byte[] { 0x10, 0x20, 0x30, 0x40 };

        private static AES_GCM_V1_Encryption MakeGcm(byte[] key) => new AES_GCM_V1_Encryption {
            FooterEncryptionKey = key,
            AadPrefix = Prefix,
            AadFileUnique = Unique
        };

        private static AES_GCM_CTR_V1_Encryption MakeCtr(byte[] key) => new AES_GCM_CTR_V1_Encryption {
            FooterEncryptionKey = key,
            AadPrefix = Prefix,
            AadFileUnique = Unique
        };

        [Fact]
        public void Gcm_Footer_Encrypt_RoundTrip() {
            AES_GCM_V1_Encryption enc = MakeGcm(Key32);
            AES_GCM_V1_Encryption dec = MakeGcm(Key32);
            byte[] plain = Encoding.ASCII.GetBytes("footer-bytes");

            // encrypt
            byte[] framed = enc.EncryptFooter(plain);

            // decrypt
            byte[] outBytes = dec.DecryptFooter(TestCryptoUtils.R(framed));
            Assert.Equal(plain, outBytes);
        }

        [Fact]
        public void Gcm_DataPageHeader_Encrypt_RoundTrip_With_PageOrdinal() {
            AES_GCM_V1_Encryption enc = MakeGcm(Key16);
            AES_GCM_V1_Encryption dec = MakeGcm(Key16);
            byte[] plain = Encoding.ASCII.GetBytes("hdr-0");

            short rg = 2, col = 3, page = 0;
            byte[] framed = enc.EncryptDataPageHeader(plain, rg, col, page);
            byte[] outBytes = dec.DecryptDataPageHeader(TestCryptoUtils.R(framed), rg, col, page);
            Assert.Equal(plain, outBytes);

            // wrong ordinal fails
            Assert.ThrowsAny<CryptographicException>(() =>
                dec.DecryptDataPageHeader(TestCryptoUtils.R(framed), rg, col, 1));
        }

        [Fact]
        public void Gcm_DataPageBody_Encrypt_RoundTrip() {
            var gcm = new AES_GCM_V1_Encryption {
                FooterEncryptionKey = Key16,
                AadPrefix = Encoding.ASCII.GetBytes("writer-aad"),
                AadFileUnique = new byte[] { 0x10, 0x20, 0x30, 0x40 }
            };

            byte[] plain = Enumerable.Range(0, 257).Select(i => (byte)i).ToArray();
            short rg = 0, col = 0, page = 5;

            byte[] framed = gcm.EncryptDataPage(plain, rg, col, page);
            byte[] outBytes = gcm.DecryptDataPage(TestCryptoUtils.R(framed), rg, col, page);

            Assert.Equal(plain, outBytes);
        }



        [Fact]
        public void Ctr_DataPageBody_Encrypt_RoundTrip() {
            AES_GCM_CTR_V1_Encryption enc = MakeCtr(Key32);
            AES_GCM_CTR_V1_Encryption dec = MakeCtr(Key32);
            byte[] plain = Enumerable.Range(0, 999).Select(i => (byte)(i % 251)).ToArray();

            short rg = 1, col = 1, page = 9;
            byte[] framed = enc.EncryptDataPage(plain, rg, col, page); // CTR framing
            byte[] outBytes = dec.DecryptDataPage(TestCryptoUtils.R(framed), rg, col, page);
            Assert.Equal(plain, outBytes);
        }

        [Theory]
        [InlineData(ParquetModules.ColumnMetaData)]
        [InlineData(ParquetModules.ColumnIndex)]
        [InlineData(ParquetModules.OffsetIndex)]
        [InlineData(ParquetModules.BloomFilter_Header)]
        [InlineData(ParquetModules.BloomFilter_Bitset)]
        public void Gcm_Module_Encrypt_RoundTrip(ParquetModules module) {
            AES_GCM_V1_Encryption enc = MakeGcm(Key16);
            AES_GCM_V1_Encryption dec = MakeGcm(Key16);
            byte[] plain = Encoding.ASCII.GetBytes($"mod-{module}");
            short rg = 7, col = 4;

            byte[] framed = enc.EncryptModuleGcm(plain, module, rg, col);
            byte[] outBytes = module switch {
                ParquetModules.ColumnMetaData => dec.DecryptColumnMetaData(TestCryptoUtils.R(framed), rg, col),
                ParquetModules.ColumnIndex => dec.DecryptColumnIndex(TestCryptoUtils.R(framed), rg, col),
                ParquetModules.OffsetIndex => dec.DecryptOffsetIndex(TestCryptoUtils.R(framed), rg, col),
                ParquetModules.BloomFilter_Header => dec.BloomFilterHeader(TestCryptoUtils.R(framed), rg, col),
                ParquetModules.BloomFilter_Bitset => dec.BloomFilterBitset(TestCryptoUtils.R(framed), rg, col),
                _ => throw new NotSupportedException()
            };
            Assert.Equal(plain, outBytes);
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Threading.Tasks;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    public class EncryptionPrimitivesTests {
        // --- Shared fixtures ---
        private static readonly byte[] Key128 = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();
        private static readonly byte[] Key256 = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] AadPrefix = Encoding.ASCII.GetBytes("employees_2025-09-27.part0");
        private static readonly byte[] AadFileUnique = new byte[] { 0xAA, 0xBB, 0xCC, 0xDD }; // short is fineâ€”spec allows impl-defined length
        private const short RowGroup = 3;
        private const short Column = 2;
        private const short Page = 7;

        private static byte[] BuildAadSuffix(ParquetModules module, bool addRowCol, bool addPage) {
            // AAD suffix = fileUnique || moduleType(1B) || [rowGroup(LE16)] || [column(LE16)] || [page(LE16)]
            using var ms = new MemoryStream();
            ms.Write(AadFileUnique, 0, AadFileUnique.Length);
            ms.WriteByte((byte)module);
            if(addRowCol) {
                ms.Write(TestCryptoUtils.Le16(RowGroup), 0, 2);
                ms.Write(TestCryptoUtils.Le16(Column), 0, 2);
            }
            if(addPage) {
                ms.Write(TestCryptoUtils.Le16(Page), 0, 2);
            }
            return ms.ToArray();
        }

        private static ThriftCompactProtocolReader MakeReader(byte[] buffer) {
            var ms = new MemoryStream(buffer);
            return new ThriftCompactProtocolReader(ms);
        }

        private static byte[] FrameGcmBuffer(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
            // length = nonce + ciphertext + tag
            int len = nonce12.Length + ciphertext.Length + tag16.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);              // 4B little-endian length
            ms.Write(nonce12, 0, nonce12.Length);                    // 12B nonce
            ms.Write(ciphertext, 0, ciphertext.Length);              // ciphertext
            ms.Write(tag16, 0, tag16.Length);                        // 16B tag
            return ms.ToArray();
        }

        private static byte[] FrameCtrBuffer(byte[] nonce12, byte[] ciphertext) {
            int len = nonce12.Length + ciphertext.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            return ms.ToArray();
        }

        // --- AES_GCM_V1 ---

        [Fact]
        public void AES_GCM_V1_RoundTrip_DataPage_WithAAD_Succeeds() {
            // Arrange
            byte[] plaintext = Encoding.ASCII.GetBytes("hello world, this is a data page payload!");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            byte[] aad = AadPrefix.Concat(BuildAadSuffix(ParquetModules.Data_Page, addRowCol: true, addPage: true)).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key256, 16);
#else
            using var gcm = new AesGcm(Key256);
#endif
            byte[] ciphertext = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ciphertext, tag, aad);

            byte[] framed = FrameGcmBuffer(nonce, ciphertext, tag);
            ThriftCompactProtocolReader reader = MakeReader(framed);

            var enc = new AES_GCM_V1_Encryption {
                FooterEncryptionKey = Key256,
                AadPrefix = AadPrefix,
                AadFileUnique = AadFileUnique
            };

            // Act
            byte[] result = enc.DecryptDataPage(reader, RowGroup, Column, Page);

            // Assert
            Assert.Equal(plaintext, result);
        }

        [Fact]
        public void AES_GCM_V1_WrongAadPrefix_Throws() {
            // Arrange
            byte[] plaintext = Encoding.ASCII.GetBytes("column index payload");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            byte[] correctAad = AadPrefix.Concat(BuildAadSuffix(ParquetModules.ColumnIndex, addRowCol: true, addPage: false)).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key128, 16);
#else
            using var gcm = new AesGcm(Key128);
#endif
            byte[] ciphertext = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ciphertext, tag, correctAad);

            byte[] framed = FrameGcmBuffer(nonce, ciphertext, tag);
            ThriftCompactProtocolReader reader = MakeReader(framed);

            byte[] wrongPrefix = Encoding.ASCII.GetBytes("WRONG_PREFIX");
            var enc = new AES_GCM_V1_Encryption {
                FooterEncryptionKey = Key128,
                AadPrefix = wrongPrefix,       // <-- wrong on purpose
                AadFileUnique = AadFileUnique
            };

            // Act + Assert
            Assert.ThrowsAny<CryptographicException>(() => {
                enc.DecryptColumnIndex(reader, RowGroup, Column);
            });
        }

        // --- AES_GCM_CTR_V1 (pages only use CTR) ---
        // NOTE: This test describes the expected behavior per spec.
        // It will FAIL with the current implementation because the IV is 16 bytes,
        // not 12, and must be nonce(12) || counter(4) with first 31 bits 0 and last bit 1.

        [Fact]
        public void AES_GCM_CTR_V1_RoundTrip_DataPage_Uses16ByteIV_Succeeds_AfterFix() {
            // Arrange
            byte[] plaintext = Encoding.ASCII.GetBytes("fast CTR page data payload");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // Build 16-byte IV = nonce(12) || counter(4) where counter = 0x00000001 (big-endian)
            byte[] iv16 = new byte[16];
            Buffer.BlockCopy(nonce, 0, iv16, 0, 12);
            iv16[12] = 0x00;
            iv16[13] = 0x00;
            iv16[14] = 0x00;
            iv16[15] = 0x01; // last bit set

            // Encrypt with AES-CTR (ECB keystream on IV, increment counter big-endian)
            byte[] ciphertext;
            using(var aes = Aes.Create()) {
                aes.Mode = CipherMode.ECB;
                aes.Padding = PaddingMode.None;
                using ICryptoTransform encryptor = aes.CreateEncryptor(Key256, new byte[16]); // IV not used in ECB
                ciphertext = XorWithCtrKeystream(encryptor, iv16, plaintext);
            }

            byte[] framed = FrameCtrBuffer(nonce, ciphertext);
            ThriftCompactProtocolReader reader = MakeReader(framed);

            var enc = new AES_GCM_CTR_V1_Encryption {
                FooterEncryptionKey = Key256,
                AadPrefix = AadPrefix,       // not used by CTR pages, but harmless
                AadFileUnique = AadFileUnique
            };

            // Act
            byte[] result = enc.DecryptDataPage(reader, RowGroup, Column, Page);

            // Assert
            Assert.Equal(plaintext, result);
        }

        // --- Magic bytes detection ---

        [Fact]
        public async Task ValidateFileAsync_SetsIsEncryptedFile_ForPARE() {
            // Arrange:  PARE .... PARE
            using var ms = new MemoryStream();
            ms.Write(Encoding.ASCII.GetBytes("PARE"), 0, 4);              // head
            ms.Write(new byte[] { 0, 1, 2, 3, 4, 5 }, 0, 6);              // body filler
            ms.Write(Encoding.ASCII.GetBytes("PARE"), 0, 4);              // tail
            ms.Position = 0;

            var actor = new TestParquetActor(ms);

            // Act
            await actor.CallValidateFileAsync();

            // Assert
            Assert.True(actor.IsEncryptedFile);
        }

        // --- Helpers ---

        // Re-usable CTR keystream xorer for test encryption
        private static byte[] XorWithCtrKeystream(ICryptoTransform ecbEncryptor, byte[] iv16, byte[] input) {
            int blockSize = 16;
            byte[] counter = (byte[])iv16.Clone();
            byte[] output = new byte[input.Length];

            int i = 0;
            while(i < input.Length) {
                byte[] ksBlock = new byte[blockSize];
                ecbEncryptor.TransformBlock(counter, 0, blockSize, ksBlock, 0);

                int n = Math.Min(blockSize, input.Length - i);
                for(int j = 0; j < n; j++) {
                    output[i + j] = (byte)(input[i + j] ^ ksBlock[j]);
                }

                // Increment counter big-endian in the last 4 bytes
                for(int p = 15; p >= 12; p--) {
                    if(++counter[p] != 0)
                        break;
                }

                i += n;
            }

            return output;
        }

        // Expose ValidateFileAsync via a tiny test shim
        private sealed class TestParquetActor : ParquetActor {
            public TestParquetActor(Stream s) : base(s) { }
            public new bool IsEncryptedFile => base.IsEncryptedFile;
            public Task CallValidateFileAsync() => base.ValidateFileAsync();
        }
    }
}

using System;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class FooterTamperTests : TestBase {

        private static MemoryStream CopyToMemory(Stream s) {
            var ms = new MemoryStream();
            s.CopyTo(ms);
            ms.Position = 0;
            return ms;
        }

        private static MemoryStream TamperTailMagic(Stream source, string newMagic /* 4 chars */) {
            if(newMagic is null || newMagic.Length != 4)
                throw new ArgumentException("newMagic must be exactly 4 ASCII chars.", nameof(newMagic));

            using MemoryStream src = CopyToMemory(source);
            byte[] buf = src.ToArray();

            // last 4 bytes = tail magic (encrypted files use "PARE")
            byte[] magicBytes = Encoding.ASCII.GetBytes(newMagic);
            Buffer.BlockCopy(magicBytes, 0, buf, buf.Length - 4, 4);

            return new MemoryStream(buf, writable: false);
        }

        private static MemoryStream TamperFooterLength(Stream source, int newFooterLen) {
            using MemoryStream src = CopyToMemory(source);
            byte[] buf = src.ToArray();

            // File layout ends with: [footer_len (LE 4 bytes)][tail_magic (4 bytes)]
            // Overwrite footer_len with nonsense to force a read failure.
            byte[] len = BitConverter.GetBytes(newFooterLen);
            Buffer.BlockCopy(len, 0, buf, buf.Length - 8, 4);

            return new MemoryStream(buf, writable: false);
        }

        [Fact]
        public async Task TailMagic_Tampered_ValidateFile_Fails_And_Open_Fails() {
            using Stream s = OpenTestFile("encryption/algo=gcm,mode=EF,aad=none,uniform=Y_file-16.parquet");
            using MemoryStream tampered = TamperTailMagic(s, "PAXX");

            // 1) Validation must fail on bad tail magic
            var actor = new ParquetActor(tampered);
            await Assert.ThrowsAsync<IOException>(() => actor.ValidateFileAsync());

            // 2) Reader creation should fail
            tampered.Position = 0;
            await Assert.ThrowsAnyAsync<Exception>(async () => {
                using ParquetReader _ = await ParquetReader.CreateAsync(tampered, new ParquetOptions {
                    FooterSigningKey = "footerKey-16byte",
                    AADPrefix = null
                });
            });
        }

        [Theory]
        [InlineData(0)]            // impossible small
        [InlineData(int.MaxValue)] // absurdly large
        public async Task FooterLength_Tampered_Reader_Fails(int newLen) {
            using Stream s = OpenTestFile("encryption/algo=gcm,mode=EF,aad=none,uniform=Y_file-16.parquet");
            using MemoryStream tampered = TamperFooterLength(s, newLen);

            await Assert.ThrowsAnyAsync<Exception>(async () => {
                using ParquetReader _ = await ParquetReader.CreateAsync(tampered, new ParquetOptions {
                    FooterSigningKey = "footerKey-16byte",
                    AADPrefix = null
                });
            });
        }

        [Fact]
        public async Task HeadMagic_Tampered_ValidateFile_Fails_And_Open_Fails() {
            using Stream s = OpenTestFile("encryption/algo=gcm,mode=EF,aad=none,uniform=Y_file-16.parquet");
            using MemoryStream ms = new MemoryStream();
            s.CopyTo(ms);
            byte[] buf = ms.ToArray();

            // first 4 bytes = head magic; encrypted files use "PARE"
            byte[] bad = Encoding.ASCII.GetBytes("PAXX");
            Buffer.BlockCopy(bad, 0, buf, 0, 4);

            using var tampered = new MemoryStream(buf, writable: false);

            var actor = new ParquetActor(tampered);
            await Assert.ThrowsAsync<IOException>(() => actor.ValidateFileAsync());

            tampered.Position = 0;
            await Assert.ThrowsAnyAsync<Exception>(async () => {
                using ParquetReader _ = await ParquetReader.CreateAsync(tampered, new ParquetOptions {
                    FooterSigningKey = "footerKey-16byte",
                    AADPrefix = null
                });
            });
        }
    }
}

using System;
using System.IO;
using System.Linq;
using Parquet.Encryption;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class FramingValidationTests {
        private static readonly byte[] Key = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();

        [Fact]
        public void Gcm_Framing_Too_Short_Throws_InvalidData() {
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(8), 0, 4); // impossible total (< 12 + 16)
            ms.Write(new byte[8], 0, 8);
            var enc = new AES_GCM_V1_Encryption { FooterEncryptionKey = Key, AadFileUnique = new byte[] { 1 } };
            Assert.Throws<InvalidDataException>(() => enc.DecryptColumnIndex(TestCryptoUtils.R(ms.ToArray()), 0, 0));
        }

        [Fact]
        public void Ctr_Framing_Negative_Ciphertext_Throws_InvalidData() {
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(10), 0, 4); // < 12 (nonce)
            ms.Write(new byte[10], 0, 10);
            var enc = new AES_GCM_CTR_V1_Encryption { FooterEncryptionKey = Key, AadFileUnique = new byte[] { 1 } };
            Assert.Throws<InvalidDataException>(() => enc.DecryptDataPage(TestCryptoUtils.R(ms.ToArray()), 0, 0, 0));
        }

        [Fact]
        public void Gcm_Framing_Length_ClaimsMoreThanBuffer_Throws_InvalidData() {
            int claimed = 12 + 0 + 16 + 5; // pretend 5 extra ciphertext bytes that aren't there
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(claimed), 0, 4);
            ms.Write(new byte[12 + 0 + 16], 0, 12 + 16); // actually provide only nonce + tag
            var enc = new AES_GCM_V1_Encryption { FooterEncryptionKey = Key, AadFileUnique = new byte[] { 2 } };
            Assert.Throws<InvalidDataException>(() => enc.DecryptColumnIndex(TestCryptoUtils.R(ms.ToArray()), 0, 0));
        }

        [Fact]
        public void Gcm_Framing_Tag_Truncated_Throws_InvalidData() {
            int total = 12 + 0 + 16;             // nonce + empty ct + full tag
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(total), 0, 4);
            ms.Write(new byte[12], 0, 12);       // nonce ok
            ms.Write(new byte[8], 0, 8);         // only half the tag present
            var enc = new AES_GCM_V1_Encryption { FooterEncryptionKey = Key, AadFileUnique = new byte[] { 3 } };
            Assert.Throws<InvalidDataException>(() => enc.DecryptOffsetIndex(TestCryptoUtils.R(ms.ToArray()), 0, 0));
        }

        [Fact]
        public void Gcm_Framing_Nonce_Truncated_Throws_InvalidData() {
            int total = 12 + 0 + 16;             // claims full nonce+tag
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(total), 0, 4);
            ms.Write(new byte[10], 0, 10);       // only 10 bytes of nonce
            ms.Write(new byte[16], 0, 16);       // tag present
            var enc = new AES_GCM_V1_Encryption { FooterEncryptionKey = Key, AadFileUnique = new byte[] { 4 } };
            Assert.Throws<InvalidDataException>(() => enc.DecryptColumnMetaData(TestCryptoUtils.R(ms.ToArray()), 0, 0));
        }

        [Fact]
        public void Ctr_Framing_Length_ClaimsMoreThanBuffer_Throws_InvalidData() {
            int claimed = 12 + 8; // claims 8 bytes of ciphertext
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(claimed), 0, 4);
            ms.Write(new byte[12 + 4], 0, 12 + 4); // but only provide 4
            var enc = new AES_GCM_CTR_V1_Encryption { FooterEncryptionKey = Key, AadFileUnique = new byte[] { 5 } };
            Assert.Throws<InvalidDataException>(() => enc.DecryptDataPage(TestCryptoUtils.R(ms.ToArray()), 0, 0, 0));
        }

        [Fact]
        public void Ctr_Framing_Nonce_Truncated_Throws_InvalidData() {
            int total = 12; // minimum possible (nonce only, 0-byte ciphertext)
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(total), 0, 4);
            ms.Write(new byte[10], 0, 10); // not enough for 12B nonce
            var enc = new AES_GCM_CTR_V1_Encryption { FooterEncryptionKey = Key, AadFileUnique = new byte[] { 6 } };
            Assert.Throws<InvalidDataException>(() => enc.DecryptDataPage(TestCryptoUtils.R(ms.ToArray()), 0, 0, 0));
        }
    }
}

// src/Parquet.Test/Encryption/InteropWithParquetMr_AllCasesTests.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Interop.Inspector;
using Parquet.Data;
using Parquet.Schema;
using Parquet.Test.Integration;
using Xunit;
using Xunit.Sdk;

namespace Parquet.Test.Encryption {
    /// <summary>
    /// Interop tests against parquet-mr generated files (full matrix).
    ///
    /// IMPORTANT: Update the constants below to match how you generated your fixtures.
    /// </summary>
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class InteropWithParquetMr_AllCasesTests : TestBase {
        private readonly EncParquetInspectorClient _client;
        private const string BaseKeyUtf8 = "testBaseKey";
        private const string AadPrefixUtf8 = "mr-suite";

        public InteropWithParquetMr_AllCasesTests() {
            _client = new EncParquetInspectorClient();
        }

        public static readonly object[][] AllCasesArray = BuildAllCases().ToArray();
        public static IEnumerable<object[]> AllCases => AllCasesArray;

        public static readonly object[][] EF_Supply_MissingPrefix_Cases_Array =
            Filter(aad => aad == AAD.Supply, mode => mode == Mode.EF)
            .Select(row => new object[] { (string)row[0], (Mode)row[2], (int)row[6] })
            .ToArray();
        public static IEnumerable<object[]> EF_Supply_MissingPrefix_Cases => EF_Supply_MissingPrefix_Cases_Array;

        public static readonly object[][] PF_Supply_MissingPrefix_Cases_Array =
            Filter(aad => aad == AAD.Supply, mode => mode == Mode.PF)
            .Select(row => new object[] { (string)row[0], (Mode)row[2], (int)row[6] })
            .ToArray();
        public static IEnumerable<object[]> PF_Supply_MissingPrefix_Cases => PF_Supply_MissingPrefix_Cases_Array;

        public static readonly object[][] UniformSuccessCasesSlim_Array =
            Filter(aad => true, mode => true, uniformOnly: true)
            .Select(row => new object[] { (string)row[0], (Mode)row[2], (AAD)row[3], (int)row[6] })
            .ToArray();
        public static IEnumerable<object[]> UniformSuccessCasesSlim => UniformSuccessCasesSlim_Array;

        public static readonly object[][] PartialPlainOnlyCases_Array =
            Filter(aad => true, mode => true, uniformOnly: false)
            .Select(row => new object[] { (string)row[0], (Mode)row[2], (AAD)row[3], (int)row[6] })
            .ToArray();
        public static IEnumerable<object[]> PartialPlainOnlyCases => PartialPlainOnlyCases_Array;



        // ---------- Enums mirroring your generator ----------
        public enum Algo { Gcm, GcmCtr }
        public enum Mode { EF, PF }            // EF = encrypted footer, PF = plaintext footer (signed)
        public enum AAD { None, Stored, Supply }

        private static IEnumerable<object[]> BuildAllCases() {
            Algo[] algos = [Algo.Gcm, Algo.GcmCtr];
            Mode[] modes = [Mode.EF, Mode.PF];
            AAD[] aads = [AAD.None, AAD.Stored, AAD.Supply];
            int[] keySizes = [16, 32];

            foreach(Algo algo in algos)
                foreach(Mode mode in modes)
                    foreach(AAD aad in aads)
                        foreach(int keySize in keySizes) {
                            // Uniform
                            yield return new object[] {
                    FileName(algo, mode, aad, uniform:true,   keyMeta:false, keySize),
                    algo, mode, aad, true,  false, keySize
                };
                            // Partial with keymeta=N
                            yield return new object[] {
                    FileName(algo, mode, aad, uniform:false,  keyMeta:false, keySize),
                    algo, mode, aad, false, false, keySize
                };
                            // Partial with keymeta=Y
                            yield return new object[] {
                    FileName(algo, mode, aad, uniform:false,  keyMeta:true, keySize),
                    algo, mode, aad, false, true, keySize
                };
                        }
        }

        private static IEnumerable<object[]> Filter(
            Func<AAD, bool> aadPred,
            Func<Mode, bool> modePred,
            bool? uniformOnly = null) {
            foreach(object[] row in AllCases) {
                var aad = (AAD)row[3];
                var mode = (Mode)row[2];
                bool isUniform = (bool)row[4];

                if(!aadPred(aad) || !modePred(mode))
                    continue;
                if(uniformOnly.HasValue && uniformOnly.Value != isUniform)
                    continue;

                yield return row;
            }
        }

        private static string FileName(Algo algo, Mode mode, AAD aad, bool uniform, bool keyMeta, int keySize) {
            string a = algo == Algo.Gcm ? "gcm" : "gcm_ctr";
            string m = mode.ToString(); // EF/PF
            string ad = aad switch { AAD.None => "none", AAD.Stored => "stored", _ => "supply" };
            if(uniform) {
                return $"algo={a},mode={m},aad={ad},uniform=Y_file-{keySize}.parquet";
            } else {
                string km = keyMeta ? "Y" : "N";
                return $"algo={a},mode={m},aad={ad},partial=Y,keymeta={km}_file-{keySize}.parquet";
            }
        }

        // ------------ Key derivation identical to parquet-mr helper ------------
        private static byte[] DeriveKey(string baseKeyUtf8, string label, int sizeBytes) {
            using var sha = SHA256.Create();
            sha.TransformBlock(Encoding.UTF8.GetBytes(baseKeyUtf8), 0, baseKeyUtf8.Length, null, 0);
            sha.TransformBlock([0x00], 0, 1, null, 0);
            byte[] labelBytes = Encoding.UTF8.GetBytes(label);
            sha.TransformFinalBlock(labelBytes, 0, labelBytes.Length);
            byte[] full = sha.Hash!;
            if(sizeBytes == 16)
                return full.Take(16).ToArray();
            if(sizeBytes == 24)
                return full.Take(24).ToArray();
            if(sizeBytes == 32)
                return full.Take(32).ToArray();
            throw new ArgumentOutOfRangeException(nameof(sizeBytes));
        }

        private static string ToHex(byte[] key) => BitConverter.ToString(key).Replace("-", "");

        // Columns in those fixtures:
        //   name (string, required)
        //   age (int32, required)
        //   salary (double, optional)  -- encrypted in partial cases (column-key)
        //   ssn (string, optional)     -- encrypted in partial cases (column-key)
        private static readonly string[] PlainColumns = ["name", "age"];
        private static readonly string[] AllColumns = ["name", "age", "salary", "ssn"];

        // -------------------- Assertions --------------------

        [Fact]
        public void CheckTestFiles() {
            Assert.True(EF_Supply_MissingPrefix_Cases.Count() > 0, "no EF/Supply/MissingPrefix cases");
            Assert.True(PF_Supply_MissingPrefix_Cases.Count() > 0, "no PF/Supply/MissingPrefix cases");
            Assert.True(UniformSuccessCasesSlim.Count() > 0, "no UniformSuccessCasesSlim cases");
            Assert.True(PartialPlainOnlyCases.Count() > 0, "no PartialPlainOnlyCases cases");
        }

        [Theory(DisplayName = "EF Missing AAD â†’ throws")]
        [MemberData(nameof(EF_Supply_MissingPrefix_Cases), DisableDiscoveryEnumeration = false)]
        public async Task EF_With_SupplyAAD_MissingPrefix_Throws(string file, Mode mode, int keySize) {
            AssumeEf(mode);
            using Stream s = OpenTestFile($"encryption/{file}");
            var opts = new ParquetOptions {
                FooterEncryptionKey = ToHex(DeriveKey(BaseKeyUtf8, "footer", keySize)),
                AADPrefix = null
            };
            await AssertMissingAadThrowsAsync(async () => {
                using ParquetReader r = await ParquetReader.CreateAsync(s, opts);
                _ = r.RowGroupCount;
            });
        }

        // Accept either early InvalidDataException (prefix required) or
        // Crypto failures (GCM tag mismatch) depending on file metadata.
        private static async Task AssertMissingAadThrowsAsync(Func<Task> action) {
            try {
                await action();
                Assert.Fail("Expected an exception due to missing AAD prefix.");
            } catch(Exception ex) {
                bool ok =
                    ex is InvalidDataException ||
                    ex is AuthenticationTagMismatchException ||
                    ex is CryptographicException;
                Assert.True(ok, ex.Message);
            }
        }

        [Theory(DisplayName = "PF Missing AAD â†’ throws")]
        [MemberData(nameof(PF_Supply_MissingPrefix_Cases), DisableDiscoveryEnumeration = false)]
        public async Task PF_With_SupplyAAD_MissingPrefix_Throws(string file, Mode mode, int keySize) {
            AssumePf(mode);
            using Stream s = OpenTestFile($"encryption/{file}");
            var opts = new ParquetOptions {
                UsePlaintextFooter = true,
                FooterSigningKey = ToHex(DeriveKey(BaseKeyUtf8, "footer", keySize)),
                // no AADPrefix on purpose
            };
            await Assert.ThrowsAsync<InvalidDataException>(async () => {
                using ParquetReader r = await ParquetReader.CreateAsync(s, opts);
                _ = r.RowGroupCount;
            });
        }

        [Theory(DisplayName = "Can read all columns")]
        [MemberData(nameof(UniformSuccessCasesSlim), DisableDiscoveryEnumeration = false)]
        public async Task Uniform_CanRead_AllColumns(string file, Mode mode, AAD aad, int keySize) {
            using Stream s = OpenTestFile($"encryption/{file}");

            string footerHex = ToHex(DeriveKey(BaseKeyUtf8, "footer", keySize));
            var opts = new ParquetOptions();

            if(mode == Mode.EF) {
                opts.FooterEncryptionKey = footerHex;
            } else {
                opts.UsePlaintextFooter = true;
                opts.FooterSigningKey = footerHex;   // verify PF signature
                opts.FooterEncryptionKey = footerHex;   // decrypt columns in uniform mode
            }

            opts.AADPrefix = aad switch {
                AAD.None => null,
                AAD.Stored => null,               // stored in file
                AAD.Supply => AadPrefixUtf8,      // must supply
                _ => null
            };

            using ParquetReader r = await ParquetReader.CreateAsync(s, opts);
            Assert.NotNull(r.Schema);

            using ParquetRowGroupReader rg = r.OpenRowGroupReader(0);
            foreach(string name in AllColumns) {
                var df = (DataField)r.Schema.DataFields.First(f => f.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
                DataColumn col = await rg.ReadColumnAsync(df);
                Assert.NotNull(col.Data);
                Assert.True(col.Data.Length > 0);
            }
        }

        [Theory(DisplayName = "Can read plain columns only")]
        [MemberData(nameof(PartialPlainOnlyCases), DisableDiscoveryEnumeration = false)]
        public async Task Partial_CanRead_PlainColumns_Without_ColumnKeys(string file, Mode mode, AAD aad, int keySize) {
            using Stream s = OpenTestFile($"encryption/{file}");

            string footerHex = ToHex(DeriveKey(BaseKeyUtf8, "footer", keySize));
            var opts = new ParquetOptions();

            if(mode == Mode.EF) {
                opts.FooterEncryptionKey = footerHex;
            } else {
                // opts.FooterEncryptionKey = footerHex;
                opts.UsePlaintextFooter = true;
                opts.FooterSigningKey = footerHex;
                // no column keys on purpose; we will only read plaintext columns
            }

            opts.AADPrefix = aad switch {
                AAD.None => null,
                AAD.Stored => null,
                AAD.Supply => AadPrefixUtf8,
                _ => null
            };

            using ParquetReader r = await ParquetReader.CreateAsync(s, opts);
            Assert.NotNull(r.Schema);

            using ParquetRowGroupReader rg = r.OpenRowGroupReader(0);
            foreach(string name in PlainColumns) {
                var df = (DataField)r.Schema.DataFields.First(f => f.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
                DataColumn col = await rg.ReadColumnAsync(df);
                Assert.NotNull(col.Data);
                Assert.True(col.Data.Length > 0);
            }
        }

        // -------------------- Helpers --------------------
        private static void AssumeEf(Mode m) { if(m != Mode.EF) throw new XunitException("Test data assumption failed: expected EF"); }
        private static void AssumePf(Mode m) { if(m != Mode.PF) throw new XunitException("Test data assumption failed: expected PF"); }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class KeyParsingTests : TestBase {

        [Theory]
        [InlineData(16)]
        [InlineData(24)]
        [InlineData(32)]
        public void Base64_Key_Sizes_Accepted(int size) {
            byte[] keyBytes = Enumerable.Range(1, size).Select(i => (byte)i).ToArray();
            byte[] fileUnique = new byte[] { 5, 6, 7, 8 };
            string keyString = Convert.ToBase64String(keyBytes);

            // build a minimal FileCryptoMetaData with AESGCMV1 to drive DecryptFooterâ€™s selection path;
            // we donâ€™t actually decrypt; we just want decrypter setup to parse the key.
            var meta = new Meta.FileCryptoMetaData {
                EncryptionAlgorithm = new Meta.EncryptionAlgorithm {
                    AESGCMV1 = new Meta.AesGcmV1 {
                        AadFileUnique = fileUnique,
                        SupplyAadPrefix = false,
                        AadPrefix = Array.Empty<byte>()
                    }
                }
            };

            using MemoryStream ms = BuildStreamWithMetaAndEmptyEncryptedFooter(meta, keyBytes, aadPrefix: null, fileUnique: fileUnique);

            // Serialize meta and then call AES_GCM_V1_Encryption.Decrypt(...) indirectly is overkill;
            // instead, directly validate the parser via the class: we simulate by constructing
            // and setting the key with ParseKeyString behavior exposed via DecryptFooter.
            // So we just assert ParseKeyString would accept Base64 by invoking the whole flow:
            var protoWriter = new ThriftCompactProtocolWriter(ms);
            meta.Write(protoWriter);
            ms.Position = 0;

            var reader = new ThriftCompactProtocolReader(ms);

            byte[] footer = EncryptionBase.DecryptFooter(reader, keyString, aadPrefix: null, out EncryptionBase? decrypter);

            // We don't care about 'footer' value here (we didn't pass a real footer),
            // we care that we got to this point without an ArgumentException on key size.
            Assert.NotNull(decrypter);
            Assert.True(decrypter is AES_GCM_V1_Encryption or AES_GCM_CTR_V1_Encryption);
        }

        [Fact]
        public void Hex_Key_256_Accepted() {
            byte[] keyBytes = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
            string keyString = BitConverter.ToString(keyBytes).Replace("-", string.Empty); // 64 hex chars
            byte[] fileUnique = new byte[] { 7, 7, 7, 7 };

            // 32 bytes (256-bit) hex
            var meta = new Meta.FileCryptoMetaData {
                EncryptionAlgorithm = new Meta.EncryptionAlgorithm {
                    AESGCMV1 = new Meta.AesGcmV1 {
                        AadFileUnique = fileUnique,
                        SupplyAadPrefix = false,
                        AadPrefix = Array.Empty<byte>()
                    }
                }
            };

            using MemoryStream ms = BuildStreamWithMetaAndEmptyEncryptedFooter(meta, keyBytes, aadPrefix: null, fileUnique: fileUnique);
            var w = new ThriftCompactProtocolWriter(ms);
            meta.Write(w);
            ms.Position = 0;

            var r = new ThriftCompactProtocolReader(ms);
            byte[] _ = EncryptionBase.DecryptFooter(r, keyString, aadPrefix: null, out EncryptionBase? _decr);
            Assert.NotNull(_decr);
        }

        [Fact]
        public void Utf8_16byte_Accepted() {
            string keyString = "1234567890abcdef"; // 16 bytes
            byte[] keyBytes = Encoding.UTF8.GetBytes(keyString);
            byte[] fileUnique = new byte[] { 9, 9, 9, 9 };

            var meta = new Meta.FileCryptoMetaData {
                EncryptionAlgorithm = new Meta.EncryptionAlgorithm {
                    AESGCMV1 = new Meta.AesGcmV1 {
                        AadFileUnique = fileUnique,
                        SupplyAadPrefix = false,
                        AadPrefix = Array.Empty<byte>()
                    }
                }
            };

            using MemoryStream ms = BuildStreamWithMetaAndEmptyEncryptedFooter(meta, keyBytes, aadPrefix: null, fileUnique: fileUnique);
            var w = new ThriftCompactProtocolWriter(ms);
            meta.Write(w);
            ms.Position = 0;

            var r = new ThriftCompactProtocolReader(ms);
            byte[] _ = EncryptionBase.DecryptFooter(r, keyString, aadPrefix: null, out EncryptionBase? _decr);
            Assert.NotNull(_decr);
        }

        [Theory]
        [InlineData("short")]                                 // 5 bytes UTF-8
        [InlineData("not-base64@@@@")]                       // invalid base64, not hex, len != 16/24/32
        [InlineData("AB")]                                   // 1 byte hex (odd length)
        [InlineData("00112233445566778899AABBCCDDEEFF00")]   // 17 bytes hex (34 chars)
        public void Invalid_Key_Formats_Throw(string key) {
            var meta = new Meta.FileCryptoMetaData {
                EncryptionAlgorithm = new Meta.EncryptionAlgorithm {
                    AESGCMV1 = new Meta.AesGcmV1 {
                        AadFileUnique = new byte[] { 1, 2, 3, 4 },
                        SupplyAadPrefix = false,
                        AadPrefix = Array.Empty<byte>()
                    }
                }
            };

            using var ms = new MemoryStream();
            var w = new ThriftCompactProtocolWriter(ms);
            meta.Write(w);
            ms.Position = 0;

            var r = new ThriftCompactProtocolReader(ms);

            Assert.Throws<ArgumentException>(() => {
                _ = EncryptionBase.DecryptFooter(r, key, aadPrefix: null, out EncryptionBase _);
            });
        }

        private static MemoryStream BuildStreamWithMetaAndEmptyEncryptedFooter(
    Meta.FileCryptoMetaData meta,
    byte[] key,
    byte[]? aadPrefix,
    byte[] fileUnique) {
            // 1) Serialize FileCryptoMetaData
            var ms = new MemoryStream();
            var w = new ThriftCompactProtocolWriter(ms);
            meta.Write(w);

            // 2) Build GCM-framed empty footer: len(=12+0+16) | nonce(12) | ciphertext(0) | tag(16)
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] tag = new byte[16];
            byte[] plaintext = Array.Empty<byte>();    // empty footer payload
            byte[] ciphertext = Array.Empty<byte>();   // empty since plaintext empty

            // AAD = aadPrefix || (fileUnique || moduleId(Footer))
            byte[] aadSuffix = fileUnique
                .Concat(new byte[] { (byte)ParquetModules.Footer })
                .ToArray();
            byte[] aad = (aadPrefix ?? Array.Empty<byte>()).Concat(aadSuffix).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(key, 16);
#else
    using var gcm = new AesGcm(key);
#endif
            gcm.Encrypt(nonce, plaintext, ciphertext, tag, aad);

            int total = 12 + 0 + 16;
            ms.Write(BitConverter.GetBytes(total), 0, 4);
            ms.Write(nonce, 0, nonce.Length);
            ms.Write(tag, 0, tag.Length);

            ms.Position = 0;
            return ms;
        }

    }
}

using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class MixedAlgorithmTests {

#if NET6_0_OR_GREATER || NETSTANDARD2_1
        [Fact]
        public async Task CtrVariant_Roundtrip_Works() {
            var schema = new ParquetSchema(new DataField<int>("v"));
            var data = new DataColumn((DataField)schema.Fields[0], Enumerable.Range(0, 10_000).ToArray());

            var writeOpts = new ParquetOptions {
                UsePlaintextFooter = true,
                FooterSigningKey = "00112233445566778899AABBCCDDEEFF",
                UseCtrVariant = true
            };

            byte[] bytes;
            using(var ms = new MemoryStream()) {
                using(ParquetWriter w = await ParquetWriter.CreateAsync(schema, ms, writeOpts)) {
                    using ParquetRowGroupWriter rg = w.CreateRowGroup();
                    await rg.WriteColumnAsync(data);
                }
                bytes = ms.ToArray();
            }

            var readOpts = new ParquetOptions { FooterSigningKey = writeOpts.FooterSigningKey };
            int[] vals;
            using(var ms = new MemoryStream(bytes)) {
                using ParquetReader r = await ParquetReader.CreateAsync(ms, readOpts);
                using ParquetRowGroupReader rg = r.OpenRowGroupReader(0);
                DataColumn col = await rg.ReadColumnAsync((DataField)r.Schema.Fields[0]);
                vals = col.AsSpan<int>().ToArray();
            }

            Assert.Equal(Enumerable.Range(0, 10_000), vals);
        }
#endif

    }
}

using System;
using System.IO;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    [CollectionDefinition(nameof(ParquetEncryptionTestCollection), DisableParallelization = true)]
    public class ParquetEncryptionTestCollection { }

    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class ParquetEncryptionTests : TestBase {
        private const string EncryptedFile = "encrypted_utf8_aes_gcm_v1_192bit.parquet";
        private const string CorrectKey = "QFwuIKG8yb845rEufVJAgcOo"; // from your test
        private const string WrongKey = "AAAAAAAAAAAAAAAAAAAAAAAA"; // same length, wrong bytes

        /// <summary>
        /// Happy path: decrypt the sample AES-GCM v1 (192-bit key) file and confirm we can read
        /// row group 0, all data fields, with non-empty values. This uses AADPrefix = null
        /// because the file does not require a supplied prefix.
        /// </summary>
        [Fact]
        public async Task Z_Decrypts_AESGCMv1_192bit_File_And_Reads_All_Columns() {
            using Stream stream = OpenTestFile(EncryptedFile);

            var parquetOptions = new ParquetOptions {
                FooterEncryptionKey = CorrectKey,
                AADPrefix = null
            };

            using ParquetReader reader = await ParquetReader.CreateAsync(stream, parquetOptions);
            Assert.True(reader.RowGroupCount > 0);
            Assert.NotNull(reader.Schema);
            Assert.True(reader.Schema.DataFields.Length > 0);

            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);

            foreach(DataField df in reader.Schema.DataFields) {
                DataColumn dc = await rgr.ReadColumnAsync(df);

                // basic sanity checks that strongly imply successful decryption:
                Assert.Equal(df, dc.Field);
                Assert.True(dc.Data.Length > 0);

                // additional helpful checks for common text columns:
                if(df.ClrType == typeof(string)) {
                    string[] strings = (string[])dc.Data;
                    Assert.True(strings.Length > 0);
                    // ensure at least one non-null/non-empty string
                    Assert.Contains(strings, s => !string.IsNullOrEmpty(s));
                }
            }
        }

        /// <summary>
        /// Negative path: the same file with an incorrect key should throw when we attempt
        /// to read (either during footer decryption or the first column/page).
        /// We assert that some crypto/IO exception is raised.
        /// </summary>
        [Fact]
        public async Task Zz_Fails_With_Wrong_Key_On_AESGCMv1_File() {
            using Stream stream = OpenTestFile(EncryptedFile);

            var parquetOptions = new ParquetOptions {
                FooterSigningKey = WrongKey,
                AADPrefix = null
            };

            // Creating the reader may already fail; if it doesnâ€™t, reading the first column should.
            await Assert.ThrowsAnyAsync<Exception>(async () => {
                using ParquetReader reader = await ParquetReader.CreateAsync(stream, parquetOptions);
                using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
                DataField df = reader.Schema.DataFields[0];
                _ = await rgr.ReadColumnAsync(df);
            });
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class PlaintextFooterReaderTests {
        private static ParquetSchema OneIntSchema()
            => new ParquetSchema(new DataField<int>("id"));

        private static DataColumn OneIntColumn(params int[] values)
            => new DataColumn((DataField)OneIntSchema().Fields[0], values);

        private static async Task<byte[]> WriteAsync(ParquetOptions opts, params int[] values) {
            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(OneIntSchema(), ms, opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(OneIntColumn(values));
            }
            return ms.ToArray();
        }

        private static async Task<int[]> ReadAllAsync(byte[] bytes, ParquetOptions opts) {
            using var ms = new MemoryStream(bytes, writable: false);
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, opts);
            using ParquetRowGroupReader rg = reader.OpenRowGroupReader(0);
            DataColumn col = await rg.ReadColumnAsync((DataField)reader.Schema.Fields[0]);
            return col.AsSpan<int>().ToArray();
        }

#if NET6_0_OR_GREATER || NETSTANDARD2_1
        [Fact]
        public async Task SignedPlaintextFooter_WithStoredAadPrefix_ReadsOK_WithoutSupplyingPrefix() {
            var opts = new ParquetOptions {
                UsePlaintextFooter = true,
                FooterSigningKey = "00112233445566778899AABBCCDDEEFF", // hex 16B
                AADPrefix = "table=users/part=0",
                SupplyAadPrefix = false, // stored in file
            };

            byte[] file = await WriteAsync(opts, 1, 2, 3);

            // Read: do not provide aad prefix â€” should succeed because it was stored
            var readOpts = new ParquetOptions { FooterSigningKey = opts.FooterSigningKey };
            int[] vals = await ReadAllAsync(file, readOpts);

            Assert.Equal(new[] { 1, 2, 3 }, vals);
        }

        [Fact]
        public async Task SignedPlaintextFooter_WithSupplyAadPrefix_RequiresPrefixOnRead() {
            var opts = new ParquetOptions {
                UsePlaintextFooter = true,
                FooterSigningKey = "00112233445566778899AABBCCDDEEFF",
                FooterEncryptionKey = "0102030405060708090A0B0C0D0E0F10",
                AADPrefix = "dataset=events/date=2025-09-28",
                SupplyAadPrefix = true, // not stored, must be supplied by readers
            };
            byte[] file = await WriteAsync(opts, 10, 20);

            // Without prefix: should fail with a clear error
            var readOptsMissing = new ParquetOptions {
                FooterSigningKey = opts.FooterSigningKey,
                FooterEncryptionKey = opts.FooterEncryptionKey
            };
            await Assert.ThrowsAsync<InvalidDataException>(async () => {
                await ReadAllAsync(file, readOptsMissing);
            });

            // With correct prefix: succeeds
            var readOpts = new ParquetOptions {
                FooterEncryptionKey = opts.FooterEncryptionKey,
                FooterSigningKey = opts.FooterSigningKey,
                AADPrefix = opts.AADPrefix
            };
            int[] vals = await ReadAllAsync(file, readOpts);
            Assert.Equal(new[] { 10, 20 }, vals);
        }

        [Fact]
        public async Task SignedPlaintextFooter_TamperTag_FailsVerification() {
            var opts = new ParquetOptions {
                UsePlaintextFooter = true,
                FooterSigningKey = "00112233445566778899AABBCCDDEEFF",
                AADPrefix = "anything",
                SupplyAadPrefix = false
            };
            byte[] ok = await WriteAsync(opts, 7, 8, 9);

            // File layout (tail): [footerPlain][nonce(12)][tag(16)][len(4)][ 'PAR1' ]
            // Flip the last byte of the tag to break the signature.
            byte[] bad = (byte[])ok.Clone();
            // position of last 4 bytes magic:
            int magicOff = bad.Length - 4;
            // read the combined length (little-endian) sitting right before magic
            int lenOff = bad.Length - 8;
            int combinedLen = BitConverter.ToInt32(bad.AsSpan(lenOff, 4)); // footer+28
            int tagStart = magicOff - 4 /*len*/ - combinedLen + (combinedLen - 28) + 12; // footerStart + footerLen + 12
            int lastTagByte = tagStart + 15;
            bad[lastTagByte] ^= 0xFF; // flip

            var readOpts = new ParquetOptions { FooterSigningKey = opts.FooterSigningKey };
            await Assert.ThrowsAsync<InvalidDataException>(async () => {
                await ReadAllAsync(bad, readOpts);
            });
        }
#endif

        [Fact]
        public async Task LegacyPlaintextFooter_NoSigning_LoadsAndReads() {
            // No SecretKey, no encryption/signing at all.
            var opts = new ParquetOptions();
            byte[] file = await WriteAsync(opts, 4, 5, 6);

            var readOpts = new ParquetOptions();
            int[] vals = await ReadAllAsync(file, readOpts);

            Assert.Equal(new[] { 4, 5, 6 }, vals);
        }

#if NET6_0_OR_GREATER || NETSTANDARD2_1
        [Fact]
        public async Task EncryptedFooter_ModeStillWorks() {
            var opts = new ParquetOptions {
                UsePlaintextFooter = false,      // encrypted footer mode
                FooterSigningKey = Convert.ToBase64String(Enumerable.Range(0, 16).Select(i => (byte)i).ToArray()),
                AADPrefix = "tbl=orders/part=42",
                SupplyAadPrefix = false
            };
            byte[] file = await WriteAsync(opts, 100, 200, 300);

            var readOpts = new ParquetOptions { FooterSigningKey = opts.FooterSigningKey };
            int[] vals = await ReadAllAsync(file, readOpts);
            Assert.Equal(new[] { 100, 200, 300 }, vals);
        }
#endif

#if NET6_0_OR_GREATER || NETSTANDARD2_1
        [Fact]
        public async Task EncryptedFooter_MissingKey_Fails() {
            var schema = new ParquetSchema(new DataField<int>("id"));
            byte[] file;
            using(var ms = new MemoryStream()) {
                var opts = new ParquetOptions { FooterEncryptionKey = "00112233445566778899AABBCCDDEEFF" };
                using(ParquetWriter w = await ParquetWriter.CreateAsync(schema, ms, opts)) {
                    using ParquetRowGroupWriter rg = w.CreateRowGroup();
                    await rg.WriteColumnAsync(new DataColumn((DataField)schema.Fields[0], new[] { 1, 2 }));
                }
                file = ms.ToArray();
            }

            using var ms2 = new MemoryStream(file);
            await Assert.ThrowsAsync<InvalidDataException>(async () => {
                // no key provided
                using ParquetReader _ = await ParquetReader.CreateAsync(ms2, new ParquetOptions());
            });
        }
#endif

#if NET6_0_OR_GREATER || NETSTANDARD2_1
        [Fact]
        public async Task SignedPlaintextFooter_WrongAadPrefix_Fails() {
            var schema = new ParquetSchema(new DataField<int>("n"));
            byte[] file;
            var opts = new ParquetOptions {
                UsePlaintextFooter = true,
                FooterSigningKey = "00112233445566778899AABBCCDDEEFF",
                AADPrefix = "dataset=A",
                SupplyAadPrefix = true
            };
            using(var ms = new MemoryStream()) {
                using(ParquetWriter w = await ParquetWriter.CreateAsync(schema, ms, opts)) {
                    using ParquetRowGroupWriter rg = w.CreateRowGroup();
                    await rg.WriteColumnAsync(new DataColumn((DataField)schema.Fields[0], new[] { 5 }));
                } // â† w.Dispose() runs here, writing [footer][nonce|tag][len][PAR1]
                file = ms.ToArray(); // â† now it's safe to capture the final bytes
            }

            var readOpts = new ParquetOptions { FooterSigningKey = opts.FooterSigningKey, AADPrefix = "dataset=B" };
            using var ms2 = new MemoryStream(file);
            await Assert.ThrowsAsync<InvalidDataException>(async () => {
                using ParquetReader r = await ParquetReader.CreateAsync(ms2, readOpts);
                _ = r.Schema; // force read
            });
        }
#endif
    }
}

using System;
using System.IO;
using System.Text;
using Parquet.Encryption;
using Parquet.Meta.Proto;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class WriteFactoryTests {
        private static ThriftCompactProtocolWriter W(Stream s) => new ThriftCompactProtocolWriter(s);

        private static MemoryStream BuildFooterRegion(
            Meta.FileCryptoMetaData cryptoMeta,
            byte[] framedEncryptedFooter) {
            var ms = new MemoryStream();
            // [FileCryptoMetaData][framed encrypted footer]
            cryptoMeta.Write(W(ms));
            ms.Write(framedEncryptedFooter, 0, framedEncryptedFooter.Length);
            ms.Position = 0;
            return ms;
        }

        [Fact]
        public void Factory_Gcm_PrefixStored_RoundTripFooter() {
            string key = Convert.ToBase64String(new byte[16] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 });
            byte[] prefix = Encoding.ASCII.GetBytes("stored-prefix");
            (EncryptionBase enc, Meta.FileCryptoMetaData? meta) = EncryptionBase.CreateEncryptorForWrite(
                encryptionOrSigningKey: key,
                aadPrefixBytes: prefix,
                supplyAadPrefix: false,   // store in file
                useCtrVariant: false
            );

            // some plaintext footer bytes (would be a serialized FileMetaData in writer)
            byte[] footerPlain = Encoding.ASCII.GetBytes("tiny-footer");

            // encrypt
            byte[] framed = enc.EncryptFooter(footerPlain);

            // build an in-memory "footer region": meta + framed footer
            using MemoryStream region = BuildFooterRegion(meta, framed);

            // decrypt via the read-side factory
            byte[] decrypted = EncryptionBase.DecryptFooter(TestCryptoUtils.R(region), key, aadPrefix: null, out EncryptionBase? decr);
            Assert.Equal(footerPlain, decrypted);
        }

        [Fact]
        public void Factory_Gcm_PrefixSupplied_RoundTripFooter() {
            string key = Convert.ToBase64String(new byte[32] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32 });
            byte[] prefix = Encoding.ASCII.GetBytes("supply-me");

            (EncryptionBase enc, Meta.FileCryptoMetaData? meta) = EncryptionBase.CreateEncryptorForWrite(
                encryptionOrSigningKey: key,
                aadPrefixBytes: prefix,
                supplyAadPrefix: true,   // do NOT store in file
                useCtrVariant: false
            );

            byte[] footerPlain = Encoding.ASCII.GetBytes("footer-AAD-supply");
            byte[] framed = enc.EncryptFooter(footerPlain);

            using MemoryStream region = BuildFooterRegion(meta, framed);

            // must supply prefix on decrypt
            byte[] decrypted = EncryptionBase.DecryptFooter(TestCryptoUtils.R(region), key, aadPrefix: Encoding.ASCII.GetString(prefix), out _);
            Assert.Equal(footerPlain, decrypted);
        }

        [Fact]
        public void Factory_CtrVariant_Still_GcmFooter_RoundTrip() {
            string key = "sixteen-byte-key"; // 16 bytes raw UTF-8
            byte[] prefix = Encoding.ASCII.GetBytes("ctr-variant");

            (EncryptionBase enc, Meta.FileCryptoMetaData? meta) = EncryptionBase.CreateEncryptorForWrite(
                encryptionOrSigningKey: key,
                aadPrefixBytes: prefix,
                supplyAadPrefix: false,
                useCtrVariant: true   // CTR affects page bodies; footer remains GCM
            );

            byte[] footerPlain = Encoding.ASCII.GetBytes("footer-gcm-under-ctr");
            byte[] framed = enc.EncryptFooter(footerPlain);

            using MemoryStream region = BuildFooterRegion(meta, framed);

            byte[] decrypted = EncryptionBase.DecryptFooter(TestCryptoUtils.R(region), key, aadPrefix: null, out _);
            Assert.Equal(footerPlain, decrypted);
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class WriterFooterE2ETests : TestBase {

        private static ParquetSchema MakeSchema()
            => new ParquetSchema(new DataField<string>("s"));

        private static DataColumn MakeColumn(ParquetSchema schema, params string[] values) {
            var sField = (DataField)schema.Fields[0];   // field attached to the schema
            return new DataColumn(sField, values);
        }

        private static DataColumn[] SampleColumns() =>
            new[] { MakeColumn(MakeSchema(), "a", "b", "c") };

        [Fact]
        public async Task A_FooterEncrypted_GcmV1_PrefixStored_RoundTrip() {
            ParquetSchema schema = MakeSchema();
            var opts = new ParquetOptions {
                FooterEncryptionKey = Convert.ToBase64String(Enumerable.Range(1, 16).Select(i => (byte)i).ToArray()),
                AADPrefix = "stored-prefix"  // weâ€™ll store it in file in CreateEncrypterForWrite
            };

            using var ms = new MemoryStream();
            // write
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(SampleColumns()[0]);
            }

            ms.Position = 0;

            // read back (no prefix needed because itâ€™s stored in file)
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                FooterEncryptionKey = opts.FooterEncryptionKey,
                AADPrefix = null
            });
            Assert.True(reader.IsEncryptedFile);
            Assert.Equal(1, reader.RowGroupCount);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var dataField = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(dataField);
            Assert.Equal(new[] { "a", "b", "c" }, col.Data);
        }

        [Fact]
        public async Task B_FooterEncrypted_GcmV1_PrefixSupplied_RoundTrip() {
            ParquetSchema schema = MakeSchema();
            string prefix = "supply-me";
            var opts = new ParquetOptions {
                FooterEncryptionKey = Convert.ToBase64String(Enumerable.Range(1, 32).Select(i => (byte)i).ToArray()),
                AADPrefix = prefix   // weâ€™ll mark SupplyAadPrefix=true in CreateEncrypterForWrite
            };

            // tell your writer path to use SupplyAadPrefix=true (e.g., via a bool in ParquetOptions or a small temp tweak)

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(SampleColumns()[0]);
            }

            ms.Position = 0;

            // must supply prefix on read
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                FooterEncryptionKey = opts.FooterEncryptionKey,
                AADPrefix = prefix
            });
            Assert.True(reader.IsEncryptedFile);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var dataField = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(dataField);
            Assert.Equal(new[] { "a", "b", "c" }, col.Data);
        }

        [Fact]
        public async Task C_FooterEncrypted_CtrVariant_FooterStillGcm_RoundTrip() {
            ParquetSchema schema = MakeSchema();
            var opts = new ParquetOptions {
                FooterEncryptionKey = "sixteen-byte-key", // 16 bytes
                AADPrefix = "ctr-variant"
            };

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(SampleColumns()[0]);
            }

            ms.Position = 0;

            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                FooterEncryptionKey = opts.FooterEncryptionKey,
                AADPrefix = null // if stored; or same prefix if supply mode
            });
            Assert.True(reader.IsEncryptedFile);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var dataField = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(dataField);
            Assert.Equal(new[] { "a", "b", "c" }, col.Data);
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Meta;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    public class WriterPageEncryptionTests : TestBase {
        private static ParquetOptions EncryptedOptions(string key, string? aadPrefix = null)
            => new ParquetOptions {
                FooterEncryptionKey = key,      // 16/24/32 byte (or base64/hex) â€“ weâ€™ll use raw UTF-8 16B below
                AADPrefix = aadPrefix     // null = prefix stored in file when writer sets supplyAadPrefix=false
            };

        [Fact]
        public async Task A_WriteEncrypted_GcmFooterKey_RoundTrip_ReadsBack() {
            // Arrange: simple schema & data
            var schema = new ParquetSchema(new DataField<string>("name"));
            var col = new DataColumn((DataField)schema.Fields[0], new[] { "a", "b", "c", "d" });

            // 16B key (AES-128) as raw UTF-8; spec requires 16/24/32B after parsing
            ParquetOptions opts = EncryptedOptions("footerKey-16byte", aadPrefix: null);

            using var ms = new MemoryStream();

            // Act: write encrypted
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, opts)) {
                // For this step we store the AAD prefix in the file (writer default: supplyAadPrefix=false)
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(col);
            }

            // Read back
            ms.Position = 0;
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, opts);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var df = (DataField)reader.Schema.Fields[0];
            DataColumn readCol = await rgr.ReadColumnAsync(df);

            // Assert: values round-trip
            string[] actual = readCol.Data.Cast<string>().AsEnumerable<string>().ToArray();
            Assert.Equal(new[] { "a", "b", "c", "d" }, actual);
        }

        [Fact]
        public async Task B_WriterSets_CryptoMetadata_OnEncryptedColumnChunks() {
            // Arrange
            var schema = new ParquetSchema(
                new DataField<int>("id"),
                new DataField<string>("s")
            );

            var id = new DataColumn((DataField)schema.Fields[0], new[] { 1, 2, 3 });
            var s = new DataColumn((DataField)schema.Fields[1], new[] { "x", "y", "z" });

            ParquetOptions opts = EncryptedOptions("footerKey-16byte", aadPrefix: null);

            using var ms = new MemoryStream();

            // Act: write encrypted
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(id);
                await rg.WriteColumnAsync(s);
            }

            // Assert: the column chunks are marked as footer-key encrypted
            ms.Position = 0;
            var actor = new ParquetActor(ms);
            await actor.ValidateFileAsync(); // sets IsEncryptedFile when PARE magic present

            FileMetaData meta = await actor.ReadMetadataAsync(
                footerSigningKey: opts.FooterSigningKey,
                footerEncryptionKey: opts.FooterEncryptionKey,
                aadPrefix: opts.AADPrefix
            );

            Assert.NotNull(meta.RowGroups);
            Assert.Single(meta.RowGroups);

            RowGroup rowGroup = meta.RowGroups[0];
            Assert.Equal(2, rowGroup.Columns.Count);

            foreach(ColumnChunk chunk in rowGroup.Columns) {
                Assert.NotNull(chunk.CryptoMetadata);
                Assert.NotNull(chunk.CryptoMetadata!.ENCRYPTIONWITHFOOTERKEY);
                Assert.Null(chunk.CryptoMetadata.ENCRYPTIONWITHCOLUMNKEY);
            }
        }

        private static string RandomB64Key(int bytes = 16) =>
            Convert.ToBase64String(RandomNumberGenerator.GetBytes(bytes));

        [Theory]
        [InlineData(false)] // AES-GCM-V1
        [InlineData(true)]  // AES-GCM-CTR-V1
        public async Task Encrypted_WithDictionary_ThenDataPage_RoundTrips(bool useCtr) {
            var field = new DataField<string>("s");
            var schema = new ParquetSchema(field);

            var opts = new ParquetOptions {
                // 128-bit key (Base64)
                FooterEncryptionKey = RandomB64Key(16),
                // store the prefix in the file (no external supply)
                AADPrefix = null,
                SupplyAadPrefix = false,
                UseCtrVariant = useCtr,
                // force dictionary and a very small threshold so dictionary is definitely used
                UseDictionaryEncoding = true,
                DictionaryEncodingThreshold = 1.0
            };

            // Highly repetitive values to ensure a dictionary page is emitted.
            string[] values = Enumerable.Repeat("aaaa", 1000).ToArray();

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(new DataColumn(field, values));
            }

            ms.Position = 0;

            using ParquetReader reader = await ParquetReader.CreateAsync(ms, opts);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            DataColumn col = await rgr.ReadColumnAsync(field);

            Assert.Equal(values.Length, col.Data.Length);
            Assert.All<object>(col.Data.Cast<object>(), v => Assert.Equal("aaaa", (string)v!));
        }

        [Theory]
        [InlineData(false)]
        [InlineData(true)]
        public async Task Encrypted_NoDictionary_DataPageOrdinalStillStartsAtZero(bool useCtr) {
            var field = new DataField<int>("x");
            var schema = new ParquetSchema(field);

            var opts = new ParquetOptions {
                FooterEncryptionKey = RandomB64Key(16),
                AADPrefix = null,
                SupplyAadPrefix = false,
                UseCtrVariant = useCtr,
                // Disable dictionary to ensure no dict page; first data page should be ordinal 0.
                UseDictionaryEncoding = false
            };

            int[] data = Enumerable.Range(0, 256).ToArray();

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(new DataColumn(field, data));
            }

            ms.Position = 0;

            using ParquetReader reader = await ParquetReader.CreateAsync(ms, opts);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            DataColumn col = await rgr.ReadColumnAsync(field);

            Assert.Equal(data, col.Data);
        }
    }
}
